1
00:00:00,440 --> 00:00:05,720
지난 영상에서는 근육과 지방을 결합한 시뮬레이션을 설정하고 실행했습니다.

2
00:00:06,280 --> 00:00:11,000
지방 레이어에서 이두근이 불룩해지는 흥미로운 형태가 잘 반영된 것을 볼 수 있습니다.

3
00:00:11,780 --> 00:00:19,340
이제 지오메트리 캐시를 생성하고, 그것을 사용해 ML 디포머를 학습해 보겠습니다.

4
00:00:19,760 --> 00:00:25,120
먼저 ‘Generate Surface Binding’ 노드를 만들어 줍니다.

5
00:00:25,120 --> 00:00:30,680
이 노드는 피부 레이어에서 지방 레이어로의 바인딩을 생성합니다.

6
00:00:31,600 --> 00:00:37,240
여기에서 Skeletal Mesh는 피부(스킨)로 설정하겠습니다.

7
00:00:39,320 --> 00:00:40,680
블렌드 버전을 선택하세요.

8
00:00:46,480 --> 00:00:49,380
Search Radius는 1.0으로 둡니다.

9
00:00:54,360 --> 00:00:55,980
이제 계산이 시작됩니다.

10
00:01:06,980 --> 00:01:08,900
좋습니다. 결과가 나왔네요.

11
00:01:08,900 --> 00:01:11,400
여기 보이는 것이 피부입니다.

12
00:01:11,720 --> 00:01:13,660
여기서 보신 것이 바로 이 스킨입니다.

13
00:01:14,220 --> 00:01:17,060
잠시 스프링 제약(Spring Constraints)으로 들어가 보겠습니다.

14
00:01:17,640 --> 00:01:18,640
색상으로 표시되어 있습니다.

15
00:01:19,220 --> 00:01:21,720
색상의 의미는 여기에서 확인할 수 있습니다.

16
00:01:21,940 --> 00:01:24,880
기본적으로 빨간색이 보이지 않으면 잘된 것입니다.

17
00:01:25,640 --> 00:01:33,160
파란색과 초록색은 사면체 메시에 포함되어 있거나 그 표면에 있다는 뜻입니다.

18
00:01:33,880 --> 00:01:34,940
그래서 이 상태는 괜찮습니다.

19
00:01:35,180 --> 00:01:36,180
이 정보를 저장하겠습니다.

20
00:01:37,080 --> 00:01:38,060
저것을 여기에 연결하세요.

21
00:01:38,320 --> 00:01:41,940
이제 해당 정보가 Flesh 에셋 안에 저장되었습니다.

22
00:01:42,960 --> 00:01:50,000
이 시점에서 지오메트리 캐시를 만들어 그 안에 결과를 저장할 수 있습니다.

23
00:01:51,180 --> 00:01:52,780
새 지오메트리 캐시를 클릭합니다.

24
00:01:56,240 --> 00:01:58,460
이 이름을 ‘GeometryCache’로 하겠습니다.

25
00:01:58,680 --> 00:01:59,380
괜찮아 보입니다.

26
00:02:00,460 --> 00:02:02,000
Embedded Skeletal Mesh 옵션을 켭니다.

27
00:02:02,120 --> 00:02:05,360
여기서도 위와 정확히 같은 것을 지정해야 합니다.

28
00:02:05,620 --> 00:02:06,260
Skeletal Mesh 말이죠.

29
00:02:06,760 --> 00:02:07,880
블렌드 버전입니다.

30
00:02:10,800 --> 00:02:11,760
그걸 선택하세요.

31
00:02:12,020 --> 00:02:15,100
이제 ‘Generate Geometry Cache’를 누를 수 있습니다.

32
00:02:15,780 --> 00:02:16,700
진행해 보겠습니다.

33
00:02:18,140 --> 00:02:19,120
현재 계산 중입니다.

34
00:02:19,680 --> 00:02:23,940
Chaos 캐시(또는 사면체 메쉬) 시뮬레이션에서 보간하고 있습니다.

35
00:02:24,580 --> 00:02:26,480
이제 여기 지오메트리 캐시가 생성된 것을 볼 수 있습니다.

36
00:02:26,700 --> 00:02:31,080
더블 클릭해서 지오메트리 캐시를 열어 보겠습니다.

37
00:02:31,420 --> 00:02:33,300
보시다시피 이건 실제로 피부(스킨)입니다.

38
00:02:33,480 --> 00:02:34,520
더 이상 지방 레이어가 아닙니다.

39
00:02:34,580 --> 00:02:35,320
스킨입니다.

40
00:02:36,460 --> 00:02:39,820
하지만 이두 컬(bicep curl) 애니메이션을 수행하고 있죠.

41
00:02:41,500 --> 00:02:44,020
이것은 시뮬레이션으로부터 보간된 결과입니다.

42
00:02:47,730 --> 00:02:48,590
좋습니다.

43
00:02:50,650 --> 00:02:54,790
이 지오메트리 캐시를 사용해서 ML 디포머를 학습해 보겠습니다.

44
00:02:55,070 --> 00:02:59,810
그러려면 새 ML Deformer 에셋을 만들겠습니다.

45
00:03:03,400 --> 00:03:10,160
이름은 ‘Emil_ML_Deformer’로 하죠.

46
00:03:11,880 --> 00:03:12,860
더블 클릭합니다.

47
00:03:13,480 --> 00:03:16,320
여기 비어 있는 ML 디포머 에셋이 보입니다.

48
00:03:16,320 --> 00:03:20,300
Skeletal Mesh는 스킨으로 설정합니다.

49
00:03:23,800 --> 00:03:25,380
애니메이션을 로드합시다.

50
00:03:26,280 --> 00:03:30,140
기억하세요, 우리는 BicepCurl 애니메이션 시퀀스를 사용했습니다.

51
00:03:30,480 --> 00:03:36,260
학습에 사용하는 애니메이션은 시뮬레이션에 사용한 것과 반드시 일치해야 합니다.

52
00:03:37,340 --> 00:03:40,520
우리는 이두 컬 애니메이션으로 시뮬레이션을 돌렸습니다.

53
00:03:42,180 --> 00:03:43,860
이제 지오메트리 캐시를 지정합니다.

54
00:03:50,560 --> 00:03:53,480
프레임은 90개가 들어 있습니다.

55
00:03:59,720 --> 00:04:00,280
맞죠?

56
00:04:02,500 --> 00:04:05,900
이제 ‘학습(Training)’에는 입력이 필요하다는 메시지가 보일 겁니다.

57
00:04:06,120 --> 00:04:08,080
네트워크 입력을 추가하겠습니다.

58
00:04:08,280 --> 00:04:11,420
스켈레탈 메쉬를 제어하는 조인트(본)들이 입력이 됩니다.

59
00:04:12,220 --> 00:04:14,740
이 시점에서 ‘모든 본 추가(Add All Bones)’를 하겠습니다.

60
00:04:14,740 --> 00:04:19,540
그러면 스켈레탈 메쉬를 제어하는 54개의 조인트가 모두 추가됩니다.

61
00:04:19,960 --> 00:04:24,300
나중에 목록을 가지치기(prune)해서 주요 조인트만 남길 수 있습니다.

62
00:04:25,140 --> 00:04:30,900
이렇게 하면 메모리를 절약하고 네트워크의 파라미터 수도 줄일 수 있습니다.

63
00:04:32,060 --> 00:04:37,420
설정이 끝났으니 반복 횟수는 기본값으로 두겠습니다.

64
00:04:37,420 --> 00:04:38,780
빠르게 한 번 학습을 돌려 보죠.

65
00:04:39,200 --> 00:04:42,120
가능하다는 것을 보여 주는 수준의 간단한 예시입니다.

66
00:04:42,980 --> 00:04:45,800
그럼 ‘Train Model(모델 학습)’을 클릭합니다.

67
00:04:47,240 --> 00:04:49,620
보시다시피 손실 값(loss)이 이미 감소하고 있습니다.

68
00:04:49,880 --> 00:04:52,280
반복 횟수를 더 늘리면 손실을 더 줄일 수 있습니다.

69
00:04:52,680 --> 00:04:56,440
물론, 지금은 예제용 학습 데이터를 쓰고 있습니다.

70
00:04:56,660 --> 00:05:00,660
보통 원하는 프레임 수에 비해 적습니다.

71
00:05:00,820 --> 00:05:02,440
여기는 90프레임뿐입니다.

72
00:05:03,260 --> 00:05:07,160
말(Kelpie) 예시에서는 약 5,000프레임을 사용했습니다.

73
00:05:07,160 --> 00:05:07,920
그건 비교를 위한 더 큰 규모의 학습 데이터였죠.

74
00:05:09,600 --> 00:05:10,800
단지 비교용 참고 자료라고 보시면 됩니다.

75
00:05:12,080 --> 00:05:15,380
이제 테스트 모드로 넘어가겠습니다.

76
00:05:16,880 --> 00:05:24,920
검증은 테스트용 애니메이션을 학습에 사용한 것과 완전히 동일하게 설정해서 진행할 수 있습니다.

77
00:05:25,260 --> 00:05:26,420
맞게 맞춰지는지만 확인해 보는 거죠.

78
00:05:29,890 --> 00:05:31,910
이제 ‘정답(ground truth)’도 불러올 수 있습니다.

79
00:05:33,950 --> 00:05:35,290
히트맵을 켜 보겠습니다.

80
00:05:36,670 --> 00:05:38,890
델타가 어디에 적용되는지 확인해 보죠.

81
00:05:43,290 --> 00:05:46,090
보시다시피 이두근 부위에 큰 델타가 많이 적용되고 있습니다.

82
00:05:48,400 --> 00:05:56,780
말씀드렸듯이 반복 횟수를 늘리면 네트워크 정확도를 더 높일 수 있습니다.

83
00:05:56,780 --> 00:06:00,160
여기서는 개념 증명(proof of concept)만 보여 드렸습니다.

